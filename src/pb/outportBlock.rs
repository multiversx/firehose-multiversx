// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `github.com/multiversx/mx-chain-core-go/data/outport/outportBlock.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct OutportBlock {
    // message fields
    pub ShardID: u32,
    pub BlockData: ::protobuf::SingularPtrField<BlockData>,
    pub TransactionPool: ::protobuf::SingularPtrField<TransactionPool>,
    pub HeaderGasConsumption: ::protobuf::SingularPtrField<HeaderGasConsumption>,
    pub AlteredAccounts: ::std::collections::HashMap<::std::string::String, super::alteredAccount::AlteredAccount>,
    pub NotarizedHeadersHashes: ::protobuf::RepeatedField<::std::string::String>,
    pub NumberOfShards: u32,
    pub SignersIndexes: ::std::vec::Vec<u64>,
    pub HighestFinalBlockNonce: u64,
    pub HighestFinalBlockHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutportBlock {
    fn default() -> &'a OutportBlock {
        <OutportBlock as ::protobuf::Message>::default_instance()
    }
}

impl OutportBlock {
    pub fn new() -> OutportBlock {
        ::std::default::Default::default()
    }

    // uint32 ShardID = 1;


    pub fn get_ShardID(&self) -> u32 {
        self.ShardID
    }
    pub fn clear_ShardID(&mut self) {
        self.ShardID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ShardID(&mut self, v: u32) {
        self.ShardID = v;
    }

    // .proto.BlockData BlockData = 2;


    pub fn get_BlockData(&self) -> &BlockData {
        self.BlockData.as_ref().unwrap_or_else(|| <BlockData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_BlockData(&mut self) {
        self.BlockData.clear();
    }

    pub fn has_BlockData(&self) -> bool {
        self.BlockData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_BlockData(&mut self, v: BlockData) {
        self.BlockData = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_BlockData(&mut self) -> &mut BlockData {
        if self.BlockData.is_none() {
            self.BlockData.set_default();
        }
        self.BlockData.as_mut().unwrap()
    }

    // Take field
    pub fn take_BlockData(&mut self) -> BlockData {
        self.BlockData.take().unwrap_or_else(|| BlockData::new())
    }

    // .proto.TransactionPool TransactionPool = 3;


    pub fn get_TransactionPool(&self) -> &TransactionPool {
        self.TransactionPool.as_ref().unwrap_or_else(|| <TransactionPool as ::protobuf::Message>::default_instance())
    }
    pub fn clear_TransactionPool(&mut self) {
        self.TransactionPool.clear();
    }

    pub fn has_TransactionPool(&self) -> bool {
        self.TransactionPool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_TransactionPool(&mut self, v: TransactionPool) {
        self.TransactionPool = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_TransactionPool(&mut self) -> &mut TransactionPool {
        if self.TransactionPool.is_none() {
            self.TransactionPool.set_default();
        }
        self.TransactionPool.as_mut().unwrap()
    }

    // Take field
    pub fn take_TransactionPool(&mut self) -> TransactionPool {
        self.TransactionPool.take().unwrap_or_else(|| TransactionPool::new())
    }

    // .proto.HeaderGasConsumption HeaderGasConsumption = 4;


    pub fn get_HeaderGasConsumption(&self) -> &HeaderGasConsumption {
        self.HeaderGasConsumption.as_ref().unwrap_or_else(|| <HeaderGasConsumption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_HeaderGasConsumption(&mut self) {
        self.HeaderGasConsumption.clear();
    }

    pub fn has_HeaderGasConsumption(&self) -> bool {
        self.HeaderGasConsumption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_HeaderGasConsumption(&mut self, v: HeaderGasConsumption) {
        self.HeaderGasConsumption = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_HeaderGasConsumption(&mut self) -> &mut HeaderGasConsumption {
        if self.HeaderGasConsumption.is_none() {
            self.HeaderGasConsumption.set_default();
        }
        self.HeaderGasConsumption.as_mut().unwrap()
    }

    // Take field
    pub fn take_HeaderGasConsumption(&mut self) -> HeaderGasConsumption {
        self.HeaderGasConsumption.take().unwrap_or_else(|| HeaderGasConsumption::new())
    }

    // repeated .proto.OutportBlock.AlteredAccountsEntry AlteredAccounts = 5;


    pub fn get_AlteredAccounts(&self) -> &::std::collections::HashMap<::std::string::String, super::alteredAccount::AlteredAccount> {
        &self.AlteredAccounts
    }
    pub fn clear_AlteredAccounts(&mut self) {
        self.AlteredAccounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_AlteredAccounts(&mut self, v: ::std::collections::HashMap<::std::string::String, super::alteredAccount::AlteredAccount>) {
        self.AlteredAccounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AlteredAccounts(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::alteredAccount::AlteredAccount> {
        &mut self.AlteredAccounts
    }

    // Take field
    pub fn take_AlteredAccounts(&mut self) -> ::std::collections::HashMap<::std::string::String, super::alteredAccount::AlteredAccount> {
        ::std::mem::replace(&mut self.AlteredAccounts, ::std::collections::HashMap::new())
    }

    // repeated string NotarizedHeadersHashes = 6;


    pub fn get_NotarizedHeadersHashes(&self) -> &[::std::string::String] {
        &self.NotarizedHeadersHashes
    }
    pub fn clear_NotarizedHeadersHashes(&mut self) {
        self.NotarizedHeadersHashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_NotarizedHeadersHashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.NotarizedHeadersHashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_NotarizedHeadersHashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.NotarizedHeadersHashes
    }

    // Take field
    pub fn take_NotarizedHeadersHashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.NotarizedHeadersHashes, ::protobuf::RepeatedField::new())
    }

    // uint32 NumberOfShards = 7;


    pub fn get_NumberOfShards(&self) -> u32 {
        self.NumberOfShards
    }
    pub fn clear_NumberOfShards(&mut self) {
        self.NumberOfShards = 0;
    }

    // Param is passed by value, moved
    pub fn set_NumberOfShards(&mut self, v: u32) {
        self.NumberOfShards = v;
    }

    // repeated uint64 SignersIndexes = 8;


    pub fn get_SignersIndexes(&self) -> &[u64] {
        &self.SignersIndexes
    }
    pub fn clear_SignersIndexes(&mut self) {
        self.SignersIndexes.clear();
    }

    // Param is passed by value, moved
    pub fn set_SignersIndexes(&mut self, v: ::std::vec::Vec<u64>) {
        self.SignersIndexes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_SignersIndexes(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.SignersIndexes
    }

    // Take field
    pub fn take_SignersIndexes(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.SignersIndexes, ::std::vec::Vec::new())
    }

    // uint64 HighestFinalBlockNonce = 9;


    pub fn get_HighestFinalBlockNonce(&self) -> u64 {
        self.HighestFinalBlockNonce
    }
    pub fn clear_HighestFinalBlockNonce(&mut self) {
        self.HighestFinalBlockNonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_HighestFinalBlockNonce(&mut self, v: u64) {
        self.HighestFinalBlockNonce = v;
    }

    // bytes HighestFinalBlockHash = 10;


    pub fn get_HighestFinalBlockHash(&self) -> &[u8] {
        &self.HighestFinalBlockHash
    }
    pub fn clear_HighestFinalBlockHash(&mut self) {
        self.HighestFinalBlockHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_HighestFinalBlockHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.HighestFinalBlockHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_HighestFinalBlockHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.HighestFinalBlockHash
    }

    // Take field
    pub fn take_HighestFinalBlockHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.HighestFinalBlockHash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OutportBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.BlockData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.TransactionPool {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.HeaderGasConsumption {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ShardID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.BlockData)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.TransactionPool)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.HeaderGasConsumption)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::alteredAccount::AlteredAccount>>(wire_type, is, &mut self.AlteredAccounts)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.NotarizedHeadersHashes)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.NumberOfShards = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.SignersIndexes)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.HighestFinalBlockNonce = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.HighestFinalBlockHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ShardID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ShardID, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.BlockData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.TransactionPool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.HeaderGasConsumption.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::alteredAccount::AlteredAccount>>(5, &self.AlteredAccounts);
        for value in &self.NotarizedHeadersHashes {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if self.NumberOfShards != 0 {
            my_size += ::protobuf::rt::value_size(7, self.NumberOfShards, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.SignersIndexes {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.HighestFinalBlockNonce != 0 {
            my_size += ::protobuf::rt::value_size(9, self.HighestFinalBlockNonce, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.HighestFinalBlockHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.HighestFinalBlockHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ShardID != 0 {
            os.write_uint32(1, self.ShardID)?;
        }
        if let Some(ref v) = self.BlockData.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.TransactionPool.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.HeaderGasConsumption.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::alteredAccount::AlteredAccount>>(5, &self.AlteredAccounts, os)?;
        for v in &self.NotarizedHeadersHashes {
            os.write_string(6, &v)?;
        };
        if self.NumberOfShards != 0 {
            os.write_uint32(7, self.NumberOfShards)?;
        }
        for v in &self.SignersIndexes {
            os.write_uint64(8, *v)?;
        };
        if self.HighestFinalBlockNonce != 0 {
            os.write_uint64(9, self.HighestFinalBlockNonce)?;
        }
        if !self.HighestFinalBlockHash.is_empty() {
            os.write_bytes(10, &self.HighestFinalBlockHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutportBlock {
        OutportBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ShardID",
                |m: &OutportBlock| { &m.ShardID },
                |m: &mut OutportBlock| { &mut m.ShardID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockData>>(
                "BlockData",
                |m: &OutportBlock| { &m.BlockData },
                |m: &mut OutportBlock| { &mut m.BlockData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionPool>>(
                "TransactionPool",
                |m: &OutportBlock| { &m.TransactionPool },
                |m: &mut OutportBlock| { &mut m.TransactionPool },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderGasConsumption>>(
                "HeaderGasConsumption",
                |m: &OutportBlock| { &m.HeaderGasConsumption },
                |m: &mut OutportBlock| { &mut m.HeaderGasConsumption },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::alteredAccount::AlteredAccount>>(
                "AlteredAccounts",
                |m: &OutportBlock| { &m.AlteredAccounts },
                |m: &mut OutportBlock| { &mut m.AlteredAccounts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "NotarizedHeadersHashes",
                |m: &OutportBlock| { &m.NotarizedHeadersHashes },
                |m: &mut OutportBlock| { &mut m.NotarizedHeadersHashes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "NumberOfShards",
                |m: &OutportBlock| { &m.NumberOfShards },
                |m: &mut OutportBlock| { &mut m.NumberOfShards },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "SignersIndexes",
                |m: &OutportBlock| { &m.SignersIndexes },
                |m: &mut OutportBlock| { &mut m.SignersIndexes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "HighestFinalBlockNonce",
                |m: &OutportBlock| { &m.HighestFinalBlockNonce },
                |m: &mut OutportBlock| { &mut m.HighestFinalBlockNonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "HighestFinalBlockHash",
                |m: &OutportBlock| { &m.HighestFinalBlockHash },
                |m: &mut OutportBlock| { &mut m.HighestFinalBlockHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutportBlock>(
                "OutportBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutportBlock {
        static instance: ::protobuf::rt::LazyV2<OutportBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutportBlock::new)
    }
}

impl ::protobuf::Clear for OutportBlock {
    fn clear(&mut self) {
        self.ShardID = 0;
        self.BlockData.clear();
        self.TransactionPool.clear();
        self.HeaderGasConsumption.clear();
        self.AlteredAccounts.clear();
        self.NotarizedHeadersHashes.clear();
        self.NumberOfShards = 0;
        self.SignersIndexes.clear();
        self.HighestFinalBlockNonce = 0;
        self.HighestFinalBlockHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutportBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutportBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockData {
    // message fields
    pub ShardID: u32,
    pub HeaderBytes: ::std::vec::Vec<u8>,
    pub HeaderType: ::std::string::String,
    pub HeaderHash: ::std::vec::Vec<u8>,
    pub Body: ::protobuf::SingularPtrField<super::block::Body>,
    pub IntraShardMiniBlocks: ::protobuf::RepeatedField<super::block::MiniBlock>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockData {
    fn default() -> &'a BlockData {
        <BlockData as ::protobuf::Message>::default_instance()
    }
}

impl BlockData {
    pub fn new() -> BlockData {
        ::std::default::Default::default()
    }

    // uint32 ShardID = 1;


    pub fn get_ShardID(&self) -> u32 {
        self.ShardID
    }
    pub fn clear_ShardID(&mut self) {
        self.ShardID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ShardID(&mut self, v: u32) {
        self.ShardID = v;
    }

    // bytes HeaderBytes = 2;


    pub fn get_HeaderBytes(&self) -> &[u8] {
        &self.HeaderBytes
    }
    pub fn clear_HeaderBytes(&mut self) {
        self.HeaderBytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_HeaderBytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.HeaderBytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_HeaderBytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.HeaderBytes
    }

    // Take field
    pub fn take_HeaderBytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.HeaderBytes, ::std::vec::Vec::new())
    }

    // string HeaderType = 3;


    pub fn get_HeaderType(&self) -> &str {
        &self.HeaderType
    }
    pub fn clear_HeaderType(&mut self) {
        self.HeaderType.clear();
    }

    // Param is passed by value, moved
    pub fn set_HeaderType(&mut self, v: ::std::string::String) {
        self.HeaderType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_HeaderType(&mut self) -> &mut ::std::string::String {
        &mut self.HeaderType
    }

    // Take field
    pub fn take_HeaderType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.HeaderType, ::std::string::String::new())
    }

    // bytes HeaderHash = 4;


    pub fn get_HeaderHash(&self) -> &[u8] {
        &self.HeaderHash
    }
    pub fn clear_HeaderHash(&mut self) {
        self.HeaderHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_HeaderHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.HeaderHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_HeaderHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.HeaderHash
    }

    // Take field
    pub fn take_HeaderHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.HeaderHash, ::std::vec::Vec::new())
    }

    // .proto.Body Body = 5;


    pub fn get_Body(&self) -> &super::block::Body {
        self.Body.as_ref().unwrap_or_else(|| <super::block::Body as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Body(&mut self) {
        self.Body.clear();
    }

    pub fn has_Body(&self) -> bool {
        self.Body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Body(&mut self, v: super::block::Body) {
        self.Body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Body(&mut self) -> &mut super::block::Body {
        if self.Body.is_none() {
            self.Body.set_default();
        }
        self.Body.as_mut().unwrap()
    }

    // Take field
    pub fn take_Body(&mut self) -> super::block::Body {
        self.Body.take().unwrap_or_else(|| super::block::Body::new())
    }

    // repeated .proto.MiniBlock IntraShardMiniBlocks = 6;


    pub fn get_IntraShardMiniBlocks(&self) -> &[super::block::MiniBlock] {
        &self.IntraShardMiniBlocks
    }
    pub fn clear_IntraShardMiniBlocks(&mut self) {
        self.IntraShardMiniBlocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_IntraShardMiniBlocks(&mut self, v: ::protobuf::RepeatedField<super::block::MiniBlock>) {
        self.IntraShardMiniBlocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_IntraShardMiniBlocks(&mut self) -> &mut ::protobuf::RepeatedField<super::block::MiniBlock> {
        &mut self.IntraShardMiniBlocks
    }

    // Take field
    pub fn take_IntraShardMiniBlocks(&mut self) -> ::protobuf::RepeatedField<super::block::MiniBlock> {
        ::std::mem::replace(&mut self.IntraShardMiniBlocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockData {
    fn is_initialized(&self) -> bool {
        for v in &self.Body {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.IntraShardMiniBlocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ShardID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.HeaderBytes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.HeaderType)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.HeaderHash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Body)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.IntraShardMiniBlocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ShardID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ShardID, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.HeaderBytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.HeaderBytes);
        }
        if !self.HeaderType.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.HeaderType);
        }
        if !self.HeaderHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.HeaderHash);
        }
        if let Some(ref v) = self.Body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.IntraShardMiniBlocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ShardID != 0 {
            os.write_uint32(1, self.ShardID)?;
        }
        if !self.HeaderBytes.is_empty() {
            os.write_bytes(2, &self.HeaderBytes)?;
        }
        if !self.HeaderType.is_empty() {
            os.write_string(3, &self.HeaderType)?;
        }
        if !self.HeaderHash.is_empty() {
            os.write_bytes(4, &self.HeaderHash)?;
        }
        if let Some(ref v) = self.Body.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.IntraShardMiniBlocks {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockData {
        BlockData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ShardID",
                |m: &BlockData| { &m.ShardID },
                |m: &mut BlockData| { &mut m.ShardID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "HeaderBytes",
                |m: &BlockData| { &m.HeaderBytes },
                |m: &mut BlockData| { &mut m.HeaderBytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "HeaderType",
                |m: &BlockData| { &m.HeaderType },
                |m: &mut BlockData| { &mut m.HeaderType },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "HeaderHash",
                |m: &BlockData| { &m.HeaderHash },
                |m: &mut BlockData| { &mut m.HeaderHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::block::Body>>(
                "Body",
                |m: &BlockData| { &m.Body },
                |m: &mut BlockData| { &mut m.Body },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::block::MiniBlock>>(
                "IntraShardMiniBlocks",
                |m: &BlockData| { &m.IntraShardMiniBlocks },
                |m: &mut BlockData| { &mut m.IntraShardMiniBlocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockData>(
                "BlockData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockData {
        static instance: ::protobuf::rt::LazyV2<BlockData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockData::new)
    }
}

impl ::protobuf::Clear for BlockData {
    fn clear(&mut self) {
        self.ShardID = 0;
        self.HeaderBytes.clear();
        self.HeaderType.clear();
        self.HeaderHash.clear();
        self.Body.clear();
        self.IntraShardMiniBlocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionPool {
    // message fields
    pub Transactions: ::std::collections::HashMap<::std::string::String, TxInfo>,
    pub SmartContractResults: ::std::collections::HashMap<::std::string::String, SCRInfo>,
    pub Rewards: ::std::collections::HashMap<::std::string::String, RewardInfo>,
    pub Receipts: ::std::collections::HashMap<::std::string::String, super::receipt::Receipt>,
    pub InvalidTxs: ::std::collections::HashMap<::std::string::String, TxInfo>,
    pub Logs: ::protobuf::RepeatedField<LogData>,
    pub ScheduledExecutedSCRSHashesPrevBlock: ::protobuf::RepeatedField<::std::string::String>,
    pub ScheduledExecutedInvalidTxsHashesPrevBlock: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionPool {
    fn default() -> &'a TransactionPool {
        <TransactionPool as ::protobuf::Message>::default_instance()
    }
}

impl TransactionPool {
    pub fn new() -> TransactionPool {
        ::std::default::Default::default()
    }

    // repeated .proto.TransactionPool.TransactionsEntry Transactions = 1;


    pub fn get_Transactions(&self) -> &::std::collections::HashMap<::std::string::String, TxInfo> {
        &self.Transactions
    }
    pub fn clear_Transactions(&mut self) {
        self.Transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_Transactions(&mut self, v: ::std::collections::HashMap<::std::string::String, TxInfo>) {
        self.Transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Transactions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, TxInfo> {
        &mut self.Transactions
    }

    // Take field
    pub fn take_Transactions(&mut self) -> ::std::collections::HashMap<::std::string::String, TxInfo> {
        ::std::mem::replace(&mut self.Transactions, ::std::collections::HashMap::new())
    }

    // repeated .proto.TransactionPool.SmartContractResultsEntry SmartContractResults = 2;


    pub fn get_SmartContractResults(&self) -> &::std::collections::HashMap<::std::string::String, SCRInfo> {
        &self.SmartContractResults
    }
    pub fn clear_SmartContractResults(&mut self) {
        self.SmartContractResults.clear();
    }

    // Param is passed by value, moved
    pub fn set_SmartContractResults(&mut self, v: ::std::collections::HashMap<::std::string::String, SCRInfo>) {
        self.SmartContractResults = v;
    }

    // Mutable pointer to the field.
    pub fn mut_SmartContractResults(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, SCRInfo> {
        &mut self.SmartContractResults
    }

    // Take field
    pub fn take_SmartContractResults(&mut self) -> ::std::collections::HashMap<::std::string::String, SCRInfo> {
        ::std::mem::replace(&mut self.SmartContractResults, ::std::collections::HashMap::new())
    }

    // repeated .proto.TransactionPool.RewardsEntry Rewards = 3;


    pub fn get_Rewards(&self) -> &::std::collections::HashMap<::std::string::String, RewardInfo> {
        &self.Rewards
    }
    pub fn clear_Rewards(&mut self) {
        self.Rewards.clear();
    }

    // Param is passed by value, moved
    pub fn set_Rewards(&mut self, v: ::std::collections::HashMap<::std::string::String, RewardInfo>) {
        self.Rewards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Rewards(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, RewardInfo> {
        &mut self.Rewards
    }

    // Take field
    pub fn take_Rewards(&mut self) -> ::std::collections::HashMap<::std::string::String, RewardInfo> {
        ::std::mem::replace(&mut self.Rewards, ::std::collections::HashMap::new())
    }

    // repeated .proto.TransactionPool.ReceiptsEntry Receipts = 4;


    pub fn get_Receipts(&self) -> &::std::collections::HashMap<::std::string::String, super::receipt::Receipt> {
        &self.Receipts
    }
    pub fn clear_Receipts(&mut self) {
        self.Receipts.clear();
    }

    // Param is passed by value, moved
    pub fn set_Receipts(&mut self, v: ::std::collections::HashMap<::std::string::String, super::receipt::Receipt>) {
        self.Receipts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Receipts(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::receipt::Receipt> {
        &mut self.Receipts
    }

    // Take field
    pub fn take_Receipts(&mut self) -> ::std::collections::HashMap<::std::string::String, super::receipt::Receipt> {
        ::std::mem::replace(&mut self.Receipts, ::std::collections::HashMap::new())
    }

    // repeated .proto.TransactionPool.InvalidTxsEntry InvalidTxs = 5;


    pub fn get_InvalidTxs(&self) -> &::std::collections::HashMap<::std::string::String, TxInfo> {
        &self.InvalidTxs
    }
    pub fn clear_InvalidTxs(&mut self) {
        self.InvalidTxs.clear();
    }

    // Param is passed by value, moved
    pub fn set_InvalidTxs(&mut self, v: ::std::collections::HashMap<::std::string::String, TxInfo>) {
        self.InvalidTxs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_InvalidTxs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, TxInfo> {
        &mut self.InvalidTxs
    }

    // Take field
    pub fn take_InvalidTxs(&mut self) -> ::std::collections::HashMap<::std::string::String, TxInfo> {
        ::std::mem::replace(&mut self.InvalidTxs, ::std::collections::HashMap::new())
    }

    // repeated .proto.LogData Logs = 6;


    pub fn get_Logs(&self) -> &[LogData] {
        &self.Logs
    }
    pub fn clear_Logs(&mut self) {
        self.Logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_Logs(&mut self, v: ::protobuf::RepeatedField<LogData>) {
        self.Logs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Logs(&mut self) -> &mut ::protobuf::RepeatedField<LogData> {
        &mut self.Logs
    }

    // Take field
    pub fn take_Logs(&mut self) -> ::protobuf::RepeatedField<LogData> {
        ::std::mem::replace(&mut self.Logs, ::protobuf::RepeatedField::new())
    }

    // repeated string ScheduledExecutedSCRSHashesPrevBlock = 7;


    pub fn get_ScheduledExecutedSCRSHashesPrevBlock(&self) -> &[::std::string::String] {
        &self.ScheduledExecutedSCRSHashesPrevBlock
    }
    pub fn clear_ScheduledExecutedSCRSHashesPrevBlock(&mut self) {
        self.ScheduledExecutedSCRSHashesPrevBlock.clear();
    }

    // Param is passed by value, moved
    pub fn set_ScheduledExecutedSCRSHashesPrevBlock(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ScheduledExecutedSCRSHashesPrevBlock = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ScheduledExecutedSCRSHashesPrevBlock(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ScheduledExecutedSCRSHashesPrevBlock
    }

    // Take field
    pub fn take_ScheduledExecutedSCRSHashesPrevBlock(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ScheduledExecutedSCRSHashesPrevBlock, ::protobuf::RepeatedField::new())
    }

    // repeated string ScheduledExecutedInvalidTxsHashesPrevBlock = 8;


    pub fn get_ScheduledExecutedInvalidTxsHashesPrevBlock(&self) -> &[::std::string::String] {
        &self.ScheduledExecutedInvalidTxsHashesPrevBlock
    }
    pub fn clear_ScheduledExecutedInvalidTxsHashesPrevBlock(&mut self) {
        self.ScheduledExecutedInvalidTxsHashesPrevBlock.clear();
    }

    // Param is passed by value, moved
    pub fn set_ScheduledExecutedInvalidTxsHashesPrevBlock(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ScheduledExecutedInvalidTxsHashesPrevBlock = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ScheduledExecutedInvalidTxsHashesPrevBlock(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ScheduledExecutedInvalidTxsHashesPrevBlock
    }

    // Take field
    pub fn take_ScheduledExecutedInvalidTxsHashesPrevBlock(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ScheduledExecutedInvalidTxsHashesPrevBlock, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TransactionPool {
    fn is_initialized(&self) -> bool {
        for v in &self.Logs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TxInfo>>(wire_type, is, &mut self.Transactions)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SCRInfo>>(wire_type, is, &mut self.SmartContractResults)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<RewardInfo>>(wire_type, is, &mut self.Rewards)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::receipt::Receipt>>(wire_type, is, &mut self.Receipts)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TxInfo>>(wire_type, is, &mut self.InvalidTxs)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Logs)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ScheduledExecutedSCRSHashesPrevBlock)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ScheduledExecutedInvalidTxsHashesPrevBlock)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TxInfo>>(1, &self.Transactions);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SCRInfo>>(2, &self.SmartContractResults);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<RewardInfo>>(3, &self.Rewards);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::receipt::Receipt>>(4, &self.Receipts);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TxInfo>>(5, &self.InvalidTxs);
        for value in &self.Logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ScheduledExecutedSCRSHashesPrevBlock {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.ScheduledExecutedInvalidTxsHashesPrevBlock {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TxInfo>>(1, &self.Transactions, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SCRInfo>>(2, &self.SmartContractResults, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<RewardInfo>>(3, &self.Rewards, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::receipt::Receipt>>(4, &self.Receipts, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TxInfo>>(5, &self.InvalidTxs, os)?;
        for v in &self.Logs {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ScheduledExecutedSCRSHashesPrevBlock {
            os.write_string(7, &v)?;
        };
        for v in &self.ScheduledExecutedInvalidTxsHashesPrevBlock {
            os.write_string(8, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionPool {
        TransactionPool::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TxInfo>>(
                "Transactions",
                |m: &TransactionPool| { &m.Transactions },
                |m: &mut TransactionPool| { &mut m.Transactions },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SCRInfo>>(
                "SmartContractResults",
                |m: &TransactionPool| { &m.SmartContractResults },
                |m: &mut TransactionPool| { &mut m.SmartContractResults },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<RewardInfo>>(
                "Rewards",
                |m: &TransactionPool| { &m.Rewards },
                |m: &mut TransactionPool| { &mut m.Rewards },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::receipt::Receipt>>(
                "Receipts",
                |m: &TransactionPool| { &m.Receipts },
                |m: &mut TransactionPool| { &mut m.Receipts },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TxInfo>>(
                "InvalidTxs",
                |m: &TransactionPool| { &m.InvalidTxs },
                |m: &mut TransactionPool| { &mut m.InvalidTxs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogData>>(
                "Logs",
                |m: &TransactionPool| { &m.Logs },
                |m: &mut TransactionPool| { &mut m.Logs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ScheduledExecutedSCRSHashesPrevBlock",
                |m: &TransactionPool| { &m.ScheduledExecutedSCRSHashesPrevBlock },
                |m: &mut TransactionPool| { &mut m.ScheduledExecutedSCRSHashesPrevBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ScheduledExecutedInvalidTxsHashesPrevBlock",
                |m: &TransactionPool| { &m.ScheduledExecutedInvalidTxsHashesPrevBlock },
                |m: &mut TransactionPool| { &mut m.ScheduledExecutedInvalidTxsHashesPrevBlock },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionPool>(
                "TransactionPool",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionPool {
        static instance: ::protobuf::rt::LazyV2<TransactionPool> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionPool::new)
    }
}

impl ::protobuf::Clear for TransactionPool {
    fn clear(&mut self) {
        self.Transactions.clear();
        self.SmartContractResults.clear();
        self.Rewards.clear();
        self.Receipts.clear();
        self.InvalidTxs.clear();
        self.Logs.clear();
        self.ScheduledExecutedSCRSHashesPrevBlock.clear();
        self.ScheduledExecutedInvalidTxsHashesPrevBlock.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionPool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionPool {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeeInfo {
    // message fields
    pub GasUsed: u64,
    pub Fee: ::std::vec::Vec<u8>,
    pub InitialPaidFee: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeInfo {
    fn default() -> &'a FeeInfo {
        <FeeInfo as ::protobuf::Message>::default_instance()
    }
}

impl FeeInfo {
    pub fn new() -> FeeInfo {
        ::std::default::Default::default()
    }

    // uint64 GasUsed = 1;


    pub fn get_GasUsed(&self) -> u64 {
        self.GasUsed
    }
    pub fn clear_GasUsed(&mut self) {
        self.GasUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_GasUsed(&mut self, v: u64) {
        self.GasUsed = v;
    }

    // bytes Fee = 2;


    pub fn get_Fee(&self) -> &[u8] {
        &self.Fee
    }
    pub fn clear_Fee(&mut self) {
        self.Fee.clear();
    }

    // Param is passed by value, moved
    pub fn set_Fee(&mut self, v: ::std::vec::Vec<u8>) {
        self.Fee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Fee(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Fee
    }

    // Take field
    pub fn take_Fee(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Fee, ::std::vec::Vec::new())
    }

    // bytes InitialPaidFee = 3;


    pub fn get_InitialPaidFee(&self) -> &[u8] {
        &self.InitialPaidFee
    }
    pub fn clear_InitialPaidFee(&mut self) {
        self.InitialPaidFee.clear();
    }

    // Param is passed by value, moved
    pub fn set_InitialPaidFee(&mut self, v: ::std::vec::Vec<u8>) {
        self.InitialPaidFee = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_InitialPaidFee(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.InitialPaidFee
    }

    // Take field
    pub fn take_InitialPaidFee(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.InitialPaidFee, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FeeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.GasUsed = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Fee)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.InitialPaidFee)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.GasUsed != 0 {
            my_size += ::protobuf::rt::value_size(1, self.GasUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.Fee.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.Fee);
        }
        if !self.InitialPaidFee.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.InitialPaidFee);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.GasUsed != 0 {
            os.write_uint64(1, self.GasUsed)?;
        }
        if !self.Fee.is_empty() {
            os.write_bytes(2, &self.Fee)?;
        }
        if !self.InitialPaidFee.is_empty() {
            os.write_bytes(3, &self.InitialPaidFee)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeInfo {
        FeeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "GasUsed",
                |m: &FeeInfo| { &m.GasUsed },
                |m: &mut FeeInfo| { &mut m.GasUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "Fee",
                |m: &FeeInfo| { &m.Fee },
                |m: &mut FeeInfo| { &mut m.Fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "InitialPaidFee",
                |m: &FeeInfo| { &m.InitialPaidFee },
                |m: &mut FeeInfo| { &mut m.InitialPaidFee },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FeeInfo>(
                "FeeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FeeInfo {
        static instance: ::protobuf::rt::LazyV2<FeeInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FeeInfo::new)
    }
}

impl ::protobuf::Clear for FeeInfo {
    fn clear(&mut self) {
        self.GasUsed = 0;
        self.Fee.clear();
        self.InitialPaidFee.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxInfo {
    // message fields
    pub Transaction: ::protobuf::SingularPtrField<super::transaction::Transaction>,
    pub FeeInfo: ::protobuf::SingularPtrField<FeeInfo>,
    pub ExecutionOrder: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxInfo {
    fn default() -> &'a TxInfo {
        <TxInfo as ::protobuf::Message>::default_instance()
    }
}

impl TxInfo {
    pub fn new() -> TxInfo {
        ::std::default::Default::default()
    }

    // .proto.Transaction Transaction = 1;


    pub fn get_Transaction(&self) -> &super::transaction::Transaction {
        self.Transaction.as_ref().unwrap_or_else(|| <super::transaction::Transaction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Transaction(&mut self) {
        self.Transaction.clear();
    }

    pub fn has_Transaction(&self) -> bool {
        self.Transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Transaction(&mut self, v: super::transaction::Transaction) {
        self.Transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Transaction(&mut self) -> &mut super::transaction::Transaction {
        if self.Transaction.is_none() {
            self.Transaction.set_default();
        }
        self.Transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_Transaction(&mut self) -> super::transaction::Transaction {
        self.Transaction.take().unwrap_or_else(|| super::transaction::Transaction::new())
    }

    // .proto.FeeInfo FeeInfo = 2;


    pub fn get_FeeInfo(&self) -> &FeeInfo {
        self.FeeInfo.as_ref().unwrap_or_else(|| <FeeInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_FeeInfo(&mut self) {
        self.FeeInfo.clear();
    }

    pub fn has_FeeInfo(&self) -> bool {
        self.FeeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FeeInfo(&mut self, v: FeeInfo) {
        self.FeeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FeeInfo(&mut self) -> &mut FeeInfo {
        if self.FeeInfo.is_none() {
            self.FeeInfo.set_default();
        }
        self.FeeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_FeeInfo(&mut self) -> FeeInfo {
        self.FeeInfo.take().unwrap_or_else(|| FeeInfo::new())
    }

    // uint32 ExecutionOrder = 3;


    pub fn get_ExecutionOrder(&self) -> u32 {
        self.ExecutionOrder
    }
    pub fn clear_ExecutionOrder(&mut self) {
        self.ExecutionOrder = 0;
    }

    // Param is passed by value, moved
    pub fn set_ExecutionOrder(&mut self, v: u32) {
        self.ExecutionOrder = v;
    }
}

impl ::protobuf::Message for TxInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.Transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.FeeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Transaction)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.FeeInfo)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ExecutionOrder = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.FeeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ExecutionOrder != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ExecutionOrder, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Transaction.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.FeeInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ExecutionOrder != 0 {
            os.write_uint32(3, self.ExecutionOrder)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxInfo {
        TxInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::transaction::Transaction>>(
                "Transaction",
                |m: &TxInfo| { &m.Transaction },
                |m: &mut TxInfo| { &mut m.Transaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeeInfo>>(
                "FeeInfo",
                |m: &TxInfo| { &m.FeeInfo },
                |m: &mut TxInfo| { &mut m.FeeInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ExecutionOrder",
                |m: &TxInfo| { &m.ExecutionOrder },
                |m: &mut TxInfo| { &mut m.ExecutionOrder },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TxInfo>(
                "TxInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TxInfo {
        static instance: ::protobuf::rt::LazyV2<TxInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TxInfo::new)
    }
}

impl ::protobuf::Clear for TxInfo {
    fn clear(&mut self) {
        self.Transaction.clear();
        self.FeeInfo.clear();
        self.ExecutionOrder = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SCRInfo {
    // message fields
    pub SmartContractResult: ::protobuf::SingularPtrField<super::smartContractResult::SmartContractResult>,
    pub FeeInfo: ::protobuf::SingularPtrField<FeeInfo>,
    pub ExecutionOrder: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SCRInfo {
    fn default() -> &'a SCRInfo {
        <SCRInfo as ::protobuf::Message>::default_instance()
    }
}

impl SCRInfo {
    pub fn new() -> SCRInfo {
        ::std::default::Default::default()
    }

    // .proto.SmartContractResult SmartContractResult = 1;


    pub fn get_SmartContractResult(&self) -> &super::smartContractResult::SmartContractResult {
        self.SmartContractResult.as_ref().unwrap_or_else(|| <super::smartContractResult::SmartContractResult as ::protobuf::Message>::default_instance())
    }
    pub fn clear_SmartContractResult(&mut self) {
        self.SmartContractResult.clear();
    }

    pub fn has_SmartContractResult(&self) -> bool {
        self.SmartContractResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SmartContractResult(&mut self, v: super::smartContractResult::SmartContractResult) {
        self.SmartContractResult = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SmartContractResult(&mut self) -> &mut super::smartContractResult::SmartContractResult {
        if self.SmartContractResult.is_none() {
            self.SmartContractResult.set_default();
        }
        self.SmartContractResult.as_mut().unwrap()
    }

    // Take field
    pub fn take_SmartContractResult(&mut self) -> super::smartContractResult::SmartContractResult {
        self.SmartContractResult.take().unwrap_or_else(|| super::smartContractResult::SmartContractResult::new())
    }

    // .proto.FeeInfo FeeInfo = 2;


    pub fn get_FeeInfo(&self) -> &FeeInfo {
        self.FeeInfo.as_ref().unwrap_or_else(|| <FeeInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_FeeInfo(&mut self) {
        self.FeeInfo.clear();
    }

    pub fn has_FeeInfo(&self) -> bool {
        self.FeeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FeeInfo(&mut self, v: FeeInfo) {
        self.FeeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FeeInfo(&mut self) -> &mut FeeInfo {
        if self.FeeInfo.is_none() {
            self.FeeInfo.set_default();
        }
        self.FeeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_FeeInfo(&mut self) -> FeeInfo {
        self.FeeInfo.take().unwrap_or_else(|| FeeInfo::new())
    }

    // uint32 ExecutionOrder = 3;


    pub fn get_ExecutionOrder(&self) -> u32 {
        self.ExecutionOrder
    }
    pub fn clear_ExecutionOrder(&mut self) {
        self.ExecutionOrder = 0;
    }

    // Param is passed by value, moved
    pub fn set_ExecutionOrder(&mut self, v: u32) {
        self.ExecutionOrder = v;
    }
}

impl ::protobuf::Message for SCRInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.SmartContractResult {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.FeeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SmartContractResult)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.FeeInfo)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ExecutionOrder = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.SmartContractResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.FeeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ExecutionOrder != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ExecutionOrder, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.SmartContractResult.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.FeeInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ExecutionOrder != 0 {
            os.write_uint32(3, self.ExecutionOrder)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SCRInfo {
        SCRInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::smartContractResult::SmartContractResult>>(
                "SmartContractResult",
                |m: &SCRInfo| { &m.SmartContractResult },
                |m: &mut SCRInfo| { &mut m.SmartContractResult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeeInfo>>(
                "FeeInfo",
                |m: &SCRInfo| { &m.FeeInfo },
                |m: &mut SCRInfo| { &mut m.FeeInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ExecutionOrder",
                |m: &SCRInfo| { &m.ExecutionOrder },
                |m: &mut SCRInfo| { &mut m.ExecutionOrder },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SCRInfo>(
                "SCRInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SCRInfo {
        static instance: ::protobuf::rt::LazyV2<SCRInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SCRInfo::new)
    }
}

impl ::protobuf::Clear for SCRInfo {
    fn clear(&mut self) {
        self.SmartContractResult.clear();
        self.FeeInfo.clear();
        self.ExecutionOrder = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SCRInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SCRInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogData {
    // message fields
    pub TxHash: ::std::string::String,
    pub Log: ::protobuf::SingularPtrField<super::log::Log>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogData {
    fn default() -> &'a LogData {
        <LogData as ::protobuf::Message>::default_instance()
    }
}

impl LogData {
    pub fn new() -> LogData {
        ::std::default::Default::default()
    }

    // string TxHash = 1;


    pub fn get_TxHash(&self) -> &str {
        &self.TxHash
    }
    pub fn clear_TxHash(&mut self) {
        self.TxHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_TxHash(&mut self, v: ::std::string::String) {
        self.TxHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_TxHash(&mut self) -> &mut ::std::string::String {
        &mut self.TxHash
    }

    // Take field
    pub fn take_TxHash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.TxHash, ::std::string::String::new())
    }

    // .proto.Log Log = 2;


    pub fn get_Log(&self) -> &super::log::Log {
        self.Log.as_ref().unwrap_or_else(|| <super::log::Log as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Log(&mut self) {
        self.Log.clear();
    }

    pub fn has_Log(&self) -> bool {
        self.Log.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Log(&mut self, v: super::log::Log) {
        self.Log = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Log(&mut self) -> &mut super::log::Log {
        if self.Log.is_none() {
            self.Log.set_default();
        }
        self.Log.as_mut().unwrap()
    }

    // Take field
    pub fn take_Log(&mut self) -> super::log::Log {
        self.Log.take().unwrap_or_else(|| super::log::Log::new())
    }
}

impl ::protobuf::Message for LogData {
    fn is_initialized(&self) -> bool {
        for v in &self.Log {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.TxHash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Log)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.TxHash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.TxHash);
        }
        if let Some(ref v) = self.Log.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.TxHash.is_empty() {
            os.write_string(1, &self.TxHash)?;
        }
        if let Some(ref v) = self.Log.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogData {
        LogData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "TxHash",
                |m: &LogData| { &m.TxHash },
                |m: &mut LogData| { &mut m.TxHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::log::Log>>(
                "Log",
                |m: &LogData| { &m.Log },
                |m: &mut LogData| { &mut m.Log },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogData>(
                "LogData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogData {
        static instance: ::protobuf::rt::LazyV2<LogData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogData::new)
    }
}

impl ::protobuf::Clear for LogData {
    fn clear(&mut self) {
        self.TxHash.clear();
        self.Log.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RewardInfo {
    // message fields
    pub Reward: ::protobuf::SingularPtrField<super::rewardTx::RewardTx>,
    pub ExecutionOrder: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RewardInfo {
    fn default() -> &'a RewardInfo {
        <RewardInfo as ::protobuf::Message>::default_instance()
    }
}

impl RewardInfo {
    pub fn new() -> RewardInfo {
        ::std::default::Default::default()
    }

    // .proto.RewardTx Reward = 1;


    pub fn get_Reward(&self) -> &super::rewardTx::RewardTx {
        self.Reward.as_ref().unwrap_or_else(|| <super::rewardTx::RewardTx as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Reward(&mut self) {
        self.Reward.clear();
    }

    pub fn has_Reward(&self) -> bool {
        self.Reward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Reward(&mut self, v: super::rewardTx::RewardTx) {
        self.Reward = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Reward(&mut self) -> &mut super::rewardTx::RewardTx {
        if self.Reward.is_none() {
            self.Reward.set_default();
        }
        self.Reward.as_mut().unwrap()
    }

    // Take field
    pub fn take_Reward(&mut self) -> super::rewardTx::RewardTx {
        self.Reward.take().unwrap_or_else(|| super::rewardTx::RewardTx::new())
    }

    // uint32 ExecutionOrder = 2;


    pub fn get_ExecutionOrder(&self) -> u32 {
        self.ExecutionOrder
    }
    pub fn clear_ExecutionOrder(&mut self) {
        self.ExecutionOrder = 0;
    }

    // Param is passed by value, moved
    pub fn set_ExecutionOrder(&mut self, v: u32) {
        self.ExecutionOrder = v;
    }
}

impl ::protobuf::Message for RewardInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.Reward {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Reward)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ExecutionOrder = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Reward.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ExecutionOrder != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ExecutionOrder, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Reward.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ExecutionOrder != 0 {
            os.write_uint32(2, self.ExecutionOrder)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RewardInfo {
        RewardInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::rewardTx::RewardTx>>(
                "Reward",
                |m: &RewardInfo| { &m.Reward },
                |m: &mut RewardInfo| { &mut m.Reward },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ExecutionOrder",
                |m: &RewardInfo| { &m.ExecutionOrder },
                |m: &mut RewardInfo| { &mut m.ExecutionOrder },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RewardInfo>(
                "RewardInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RewardInfo {
        static instance: ::protobuf::rt::LazyV2<RewardInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RewardInfo::new)
    }
}

impl ::protobuf::Clear for RewardInfo {
    fn clear(&mut self) {
        self.Reward.clear();
        self.ExecutionOrder = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RewardInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RewardInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeaderGasConsumption {
    // message fields
    pub GasProvided: u64,
    pub GasRefunded: u64,
    pub GasPenalized: u64,
    pub MaxGasPerBlock: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeaderGasConsumption {
    fn default() -> &'a HeaderGasConsumption {
        <HeaderGasConsumption as ::protobuf::Message>::default_instance()
    }
}

impl HeaderGasConsumption {
    pub fn new() -> HeaderGasConsumption {
        ::std::default::Default::default()
    }

    // uint64 GasProvided = 1;


    pub fn get_GasProvided(&self) -> u64 {
        self.GasProvided
    }
    pub fn clear_GasProvided(&mut self) {
        self.GasProvided = 0;
    }

    // Param is passed by value, moved
    pub fn set_GasProvided(&mut self, v: u64) {
        self.GasProvided = v;
    }

    // uint64 GasRefunded = 2;


    pub fn get_GasRefunded(&self) -> u64 {
        self.GasRefunded
    }
    pub fn clear_GasRefunded(&mut self) {
        self.GasRefunded = 0;
    }

    // Param is passed by value, moved
    pub fn set_GasRefunded(&mut self, v: u64) {
        self.GasRefunded = v;
    }

    // uint64 GasPenalized = 3;


    pub fn get_GasPenalized(&self) -> u64 {
        self.GasPenalized
    }
    pub fn clear_GasPenalized(&mut self) {
        self.GasPenalized = 0;
    }

    // Param is passed by value, moved
    pub fn set_GasPenalized(&mut self, v: u64) {
        self.GasPenalized = v;
    }

    // uint64 MaxGasPerBlock = 4;


    pub fn get_MaxGasPerBlock(&self) -> u64 {
        self.MaxGasPerBlock
    }
    pub fn clear_MaxGasPerBlock(&mut self) {
        self.MaxGasPerBlock = 0;
    }

    // Param is passed by value, moved
    pub fn set_MaxGasPerBlock(&mut self, v: u64) {
        self.MaxGasPerBlock = v;
    }
}

impl ::protobuf::Message for HeaderGasConsumption {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.GasProvided = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.GasRefunded = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.GasPenalized = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.MaxGasPerBlock = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.GasProvided != 0 {
            my_size += ::protobuf::rt::value_size(1, self.GasProvided, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.GasRefunded != 0 {
            my_size += ::protobuf::rt::value_size(2, self.GasRefunded, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.GasPenalized != 0 {
            my_size += ::protobuf::rt::value_size(3, self.GasPenalized, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.MaxGasPerBlock != 0 {
            my_size += ::protobuf::rt::value_size(4, self.MaxGasPerBlock, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.GasProvided != 0 {
            os.write_uint64(1, self.GasProvided)?;
        }
        if self.GasRefunded != 0 {
            os.write_uint64(2, self.GasRefunded)?;
        }
        if self.GasPenalized != 0 {
            os.write_uint64(3, self.GasPenalized)?;
        }
        if self.MaxGasPerBlock != 0 {
            os.write_uint64(4, self.MaxGasPerBlock)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeaderGasConsumption {
        HeaderGasConsumption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "GasProvided",
                |m: &HeaderGasConsumption| { &m.GasProvided },
                |m: &mut HeaderGasConsumption| { &mut m.GasProvided },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "GasRefunded",
                |m: &HeaderGasConsumption| { &m.GasRefunded },
                |m: &mut HeaderGasConsumption| { &mut m.GasRefunded },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "GasPenalized",
                |m: &HeaderGasConsumption| { &m.GasPenalized },
                |m: &mut HeaderGasConsumption| { &mut m.GasPenalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "MaxGasPerBlock",
                |m: &HeaderGasConsumption| { &m.MaxGasPerBlock },
                |m: &mut HeaderGasConsumption| { &mut m.MaxGasPerBlock },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeaderGasConsumption>(
                "HeaderGasConsumption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeaderGasConsumption {
        static instance: ::protobuf::rt::LazyV2<HeaderGasConsumption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeaderGasConsumption::new)
    }
}

impl ::protobuf::Clear for HeaderGasConsumption {
    fn clear(&mut self) {
        self.GasProvided = 0;
        self.GasRefunded = 0;
        self.GasPenalized = 0;
        self.MaxGasPerBlock = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeaderGasConsumption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderGasConsumption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidatorRatingInfo {
    // message fields
    pub PublicKey: ::std::string::String,
    pub Rating: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidatorRatingInfo {
    fn default() -> &'a ValidatorRatingInfo {
        <ValidatorRatingInfo as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorRatingInfo {
    pub fn new() -> ValidatorRatingInfo {
        ::std::default::Default::default()
    }

    // string PublicKey = 1;


    pub fn get_PublicKey(&self) -> &str {
        &self.PublicKey
    }
    pub fn clear_PublicKey(&mut self) {
        self.PublicKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_PublicKey(&mut self, v: ::std::string::String) {
        self.PublicKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PublicKey(&mut self) -> &mut ::std::string::String {
        &mut self.PublicKey
    }

    // Take field
    pub fn take_PublicKey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.PublicKey, ::std::string::String::new())
    }

    // float Rating = 2;


    pub fn get_Rating(&self) -> f32 {
        self.Rating
    }
    pub fn clear_Rating(&mut self) {
        self.Rating = 0.;
    }

    // Param is passed by value, moved
    pub fn set_Rating(&mut self, v: f32) {
        self.Rating = v;
    }
}

impl ::protobuf::Message for ValidatorRatingInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.PublicKey)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.Rating = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.PublicKey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.PublicKey);
        }
        if self.Rating != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.PublicKey.is_empty() {
            os.write_string(1, &self.PublicKey)?;
        }
        if self.Rating != 0. {
            os.write_float(2, self.Rating)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidatorRatingInfo {
        ValidatorRatingInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "PublicKey",
                |m: &ValidatorRatingInfo| { &m.PublicKey },
                |m: &mut ValidatorRatingInfo| { &mut m.PublicKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "Rating",
                |m: &ValidatorRatingInfo| { &m.Rating },
                |m: &mut ValidatorRatingInfo| { &mut m.Rating },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValidatorRatingInfo>(
                "ValidatorRatingInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValidatorRatingInfo {
        static instance: ::protobuf::rt::LazyV2<ValidatorRatingInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValidatorRatingInfo::new)
    }
}

impl ::protobuf::Clear for ValidatorRatingInfo {
    fn clear(&mut self) {
        self.PublicKey.clear();
        self.Rating = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidatorRatingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorRatingInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidatorsRating {
    // message fields
    pub ShardID: u32,
    pub Epoch: u32,
    pub ValidatorsRatingInfo: ::protobuf::RepeatedField<ValidatorRatingInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidatorsRating {
    fn default() -> &'a ValidatorsRating {
        <ValidatorsRating as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorsRating {
    pub fn new() -> ValidatorsRating {
        ::std::default::Default::default()
    }

    // uint32 ShardID = 1;


    pub fn get_ShardID(&self) -> u32 {
        self.ShardID
    }
    pub fn clear_ShardID(&mut self) {
        self.ShardID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ShardID(&mut self, v: u32) {
        self.ShardID = v;
    }

    // uint32 Epoch = 2;


    pub fn get_Epoch(&self) -> u32 {
        self.Epoch
    }
    pub fn clear_Epoch(&mut self) {
        self.Epoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_Epoch(&mut self, v: u32) {
        self.Epoch = v;
    }

    // repeated .proto.ValidatorRatingInfo ValidatorsRatingInfo = 3;


    pub fn get_ValidatorsRatingInfo(&self) -> &[ValidatorRatingInfo] {
        &self.ValidatorsRatingInfo
    }
    pub fn clear_ValidatorsRatingInfo(&mut self) {
        self.ValidatorsRatingInfo.clear();
    }

    // Param is passed by value, moved
    pub fn set_ValidatorsRatingInfo(&mut self, v: ::protobuf::RepeatedField<ValidatorRatingInfo>) {
        self.ValidatorsRatingInfo = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ValidatorsRatingInfo(&mut self) -> &mut ::protobuf::RepeatedField<ValidatorRatingInfo> {
        &mut self.ValidatorsRatingInfo
    }

    // Take field
    pub fn take_ValidatorsRatingInfo(&mut self) -> ::protobuf::RepeatedField<ValidatorRatingInfo> {
        ::std::mem::replace(&mut self.ValidatorsRatingInfo, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ValidatorsRating {
    fn is_initialized(&self) -> bool {
        for v in &self.ValidatorsRatingInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ShardID = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Epoch = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ValidatorsRatingInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ShardID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ShardID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Epoch != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Epoch, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ValidatorsRatingInfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ShardID != 0 {
            os.write_uint32(1, self.ShardID)?;
        }
        if self.Epoch != 0 {
            os.write_uint32(2, self.Epoch)?;
        }
        for v in &self.ValidatorsRatingInfo {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidatorsRating {
        ValidatorsRating::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ShardID",
                |m: &ValidatorsRating| { &m.ShardID },
                |m: &mut ValidatorsRating| { &mut m.ShardID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Epoch",
                |m: &ValidatorsRating| { &m.Epoch },
                |m: &mut ValidatorsRating| { &mut m.Epoch },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ValidatorRatingInfo>>(
                "ValidatorsRatingInfo",
                |m: &ValidatorsRating| { &m.ValidatorsRatingInfo },
                |m: &mut ValidatorsRating| { &mut m.ValidatorsRatingInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValidatorsRating>(
                "ValidatorsRating",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValidatorsRating {
        static instance: ::protobuf::rt::LazyV2<ValidatorsRating> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValidatorsRating::new)
    }
}

impl ::protobuf::Clear for ValidatorsRating {
    fn clear(&mut self) {
        self.ShardID = 0;
        self.Epoch = 0;
        self.ValidatorsRatingInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidatorsRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorsRating {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoundInfo {
    // message fields
    pub Round: u64,
    pub SignersIndexes: ::std::vec::Vec<u64>,
    pub BlockWasProposed: bool,
    pub ShardId: u32,
    pub Epoch: u32,
    pub Timestamp: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoundInfo {
    fn default() -> &'a RoundInfo {
        <RoundInfo as ::protobuf::Message>::default_instance()
    }
}

impl RoundInfo {
    pub fn new() -> RoundInfo {
        ::std::default::Default::default()
    }

    // uint64 Round = 1;


    pub fn get_Round(&self) -> u64 {
        self.Round
    }
    pub fn clear_Round(&mut self) {
        self.Round = 0;
    }

    // Param is passed by value, moved
    pub fn set_Round(&mut self, v: u64) {
        self.Round = v;
    }

    // repeated uint64 SignersIndexes = 2;


    pub fn get_SignersIndexes(&self) -> &[u64] {
        &self.SignersIndexes
    }
    pub fn clear_SignersIndexes(&mut self) {
        self.SignersIndexes.clear();
    }

    // Param is passed by value, moved
    pub fn set_SignersIndexes(&mut self, v: ::std::vec::Vec<u64>) {
        self.SignersIndexes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_SignersIndexes(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.SignersIndexes
    }

    // Take field
    pub fn take_SignersIndexes(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.SignersIndexes, ::std::vec::Vec::new())
    }

    // bool BlockWasProposed = 3;


    pub fn get_BlockWasProposed(&self) -> bool {
        self.BlockWasProposed
    }
    pub fn clear_BlockWasProposed(&mut self) {
        self.BlockWasProposed = false;
    }

    // Param is passed by value, moved
    pub fn set_BlockWasProposed(&mut self, v: bool) {
        self.BlockWasProposed = v;
    }

    // uint32 ShardId = 4;


    pub fn get_ShardId(&self) -> u32 {
        self.ShardId
    }
    pub fn clear_ShardId(&mut self) {
        self.ShardId = 0;
    }

    // Param is passed by value, moved
    pub fn set_ShardId(&mut self, v: u32) {
        self.ShardId = v;
    }

    // uint32 Epoch = 5;


    pub fn get_Epoch(&self) -> u32 {
        self.Epoch
    }
    pub fn clear_Epoch(&mut self) {
        self.Epoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_Epoch(&mut self, v: u32) {
        self.Epoch = v;
    }

    // uint64 Timestamp = 6;


    pub fn get_Timestamp(&self) -> u64 {
        self.Timestamp
    }
    pub fn clear_Timestamp(&mut self) {
        self.Timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_Timestamp(&mut self, v: u64) {
        self.Timestamp = v;
    }
}

impl ::protobuf::Message for RoundInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Round = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.SignersIndexes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.BlockWasProposed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ShardId = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Epoch = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.Timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Round != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Round, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.SignersIndexes {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.BlockWasProposed != false {
            my_size += 2;
        }
        if self.ShardId != 0 {
            my_size += ::protobuf::rt::value_size(4, self.ShardId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Epoch != 0 {
            my_size += ::protobuf::rt::value_size(5, self.Epoch, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Timestamp != 0 {
            my_size += ::protobuf::rt::value_size(6, self.Timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Round != 0 {
            os.write_uint64(1, self.Round)?;
        }
        for v in &self.SignersIndexes {
            os.write_uint64(2, *v)?;
        };
        if self.BlockWasProposed != false {
            os.write_bool(3, self.BlockWasProposed)?;
        }
        if self.ShardId != 0 {
            os.write_uint32(4, self.ShardId)?;
        }
        if self.Epoch != 0 {
            os.write_uint32(5, self.Epoch)?;
        }
        if self.Timestamp != 0 {
            os.write_uint64(6, self.Timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoundInfo {
        RoundInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "Round",
                |m: &RoundInfo| { &m.Round },
                |m: &mut RoundInfo| { &mut m.Round },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "SignersIndexes",
                |m: &RoundInfo| { &m.SignersIndexes },
                |m: &mut RoundInfo| { &mut m.SignersIndexes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "BlockWasProposed",
                |m: &RoundInfo| { &m.BlockWasProposed },
                |m: &mut RoundInfo| { &mut m.BlockWasProposed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ShardId",
                |m: &RoundInfo| { &m.ShardId },
                |m: &mut RoundInfo| { &mut m.ShardId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Epoch",
                |m: &RoundInfo| { &m.Epoch },
                |m: &mut RoundInfo| { &mut m.Epoch },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "Timestamp",
                |m: &RoundInfo| { &m.Timestamp },
                |m: &mut RoundInfo| { &mut m.Timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoundInfo>(
                "RoundInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoundInfo {
        static instance: ::protobuf::rt::LazyV2<RoundInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoundInfo::new)
    }
}

impl ::protobuf::Clear for RoundInfo {
    fn clear(&mut self) {
        self.Round = 0;
        self.SignersIndexes.clear();
        self.BlockWasProposed = false;
        self.ShardId = 0;
        self.Epoch = 0;
        self.Timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoundInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoundInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoundsInfo {
    // message fields
    pub ShardID: u32,
    pub RoundsInfo: ::protobuf::RepeatedField<RoundInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoundsInfo {
    fn default() -> &'a RoundsInfo {
        <RoundsInfo as ::protobuf::Message>::default_instance()
    }
}

impl RoundsInfo {
    pub fn new() -> RoundsInfo {
        ::std::default::Default::default()
    }

    // uint32 ShardID = 1;


    pub fn get_ShardID(&self) -> u32 {
        self.ShardID
    }
    pub fn clear_ShardID(&mut self) {
        self.ShardID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ShardID(&mut self, v: u32) {
        self.ShardID = v;
    }

    // repeated .proto.RoundInfo RoundsInfo = 2;


    pub fn get_RoundsInfo(&self) -> &[RoundInfo] {
        &self.RoundsInfo
    }
    pub fn clear_RoundsInfo(&mut self) {
        self.RoundsInfo.clear();
    }

    // Param is passed by value, moved
    pub fn set_RoundsInfo(&mut self, v: ::protobuf::RepeatedField<RoundInfo>) {
        self.RoundsInfo = v;
    }

    // Mutable pointer to the field.
    pub fn mut_RoundsInfo(&mut self) -> &mut ::protobuf::RepeatedField<RoundInfo> {
        &mut self.RoundsInfo
    }

    // Take field
    pub fn take_RoundsInfo(&mut self) -> ::protobuf::RepeatedField<RoundInfo> {
        ::std::mem::replace(&mut self.RoundsInfo, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RoundsInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.RoundsInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ShardID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.RoundsInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ShardID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ShardID, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.RoundsInfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ShardID != 0 {
            os.write_uint32(1, self.ShardID)?;
        }
        for v in &self.RoundsInfo {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoundsInfo {
        RoundsInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ShardID",
                |m: &RoundsInfo| { &m.ShardID },
                |m: &mut RoundsInfo| { &mut m.ShardID },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoundInfo>>(
                "RoundsInfo",
                |m: &RoundsInfo| { &m.RoundsInfo },
                |m: &mut RoundsInfo| { &mut m.RoundsInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoundsInfo>(
                "RoundsInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoundsInfo {
        static instance: ::protobuf::rt::LazyV2<RoundsInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoundsInfo::new)
    }
}

impl ::protobuf::Clear for RoundsInfo {
    fn clear(&mut self) {
        self.ShardID = 0;
        self.RoundsInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoundsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoundsInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PubKeys {
    // message fields
    pub Keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PubKeys {
    fn default() -> &'a PubKeys {
        <PubKeys as ::protobuf::Message>::default_instance()
    }
}

impl PubKeys {
    pub fn new() -> PubKeys {
        ::std::default::Default::default()
    }

    // repeated bytes Keys = 1;


    pub fn get_Keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.Keys
    }
    pub fn clear_Keys(&mut self) {
        self.Keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_Keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.Keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.Keys
    }

    // Take field
    pub fn take_Keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.Keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PubKeys {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.Keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Keys {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Keys {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PubKeys {
        PubKeys::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "Keys",
                |m: &PubKeys| { &m.Keys },
                |m: &mut PubKeys| { &mut m.Keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PubKeys>(
                "PubKeys",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PubKeys {
        static instance: ::protobuf::rt::LazyV2<PubKeys> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PubKeys::new)
    }
}

impl ::protobuf::Clear for PubKeys {
    fn clear(&mut self) {
        self.Keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PubKeys {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PubKeys {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidatorsPubKeys {
    // message fields
    pub ShardID: u32,
    pub ShardValidatorsPubKeys: ::std::collections::HashMap<u32, PubKeys>,
    pub Epoch: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidatorsPubKeys {
    fn default() -> &'a ValidatorsPubKeys {
        <ValidatorsPubKeys as ::protobuf::Message>::default_instance()
    }
}

impl ValidatorsPubKeys {
    pub fn new() -> ValidatorsPubKeys {
        ::std::default::Default::default()
    }

    // uint32 ShardID = 1;


    pub fn get_ShardID(&self) -> u32 {
        self.ShardID
    }
    pub fn clear_ShardID(&mut self) {
        self.ShardID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ShardID(&mut self, v: u32) {
        self.ShardID = v;
    }

    // repeated .proto.ValidatorsPubKeys.ShardValidatorsPubKeysEntry ShardValidatorsPubKeys = 2;


    pub fn get_ShardValidatorsPubKeys(&self) -> &::std::collections::HashMap<u32, PubKeys> {
        &self.ShardValidatorsPubKeys
    }
    pub fn clear_ShardValidatorsPubKeys(&mut self) {
        self.ShardValidatorsPubKeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_ShardValidatorsPubKeys(&mut self, v: ::std::collections::HashMap<u32, PubKeys>) {
        self.ShardValidatorsPubKeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ShardValidatorsPubKeys(&mut self) -> &mut ::std::collections::HashMap<u32, PubKeys> {
        &mut self.ShardValidatorsPubKeys
    }

    // Take field
    pub fn take_ShardValidatorsPubKeys(&mut self) -> ::std::collections::HashMap<u32, PubKeys> {
        ::std::mem::replace(&mut self.ShardValidatorsPubKeys, ::std::collections::HashMap::new())
    }

    // uint32 Epoch = 3;


    pub fn get_Epoch(&self) -> u32 {
        self.Epoch
    }
    pub fn clear_Epoch(&mut self) {
        self.Epoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_Epoch(&mut self, v: u32) {
        self.Epoch = v;
    }
}

impl ::protobuf::Message for ValidatorsPubKeys {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ShardID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<PubKeys>>(wire_type, is, &mut self.ShardValidatorsPubKeys)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.Epoch = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ShardID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ShardID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<PubKeys>>(2, &self.ShardValidatorsPubKeys);
        if self.Epoch != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Epoch, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ShardID != 0 {
            os.write_uint32(1, self.ShardID)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<PubKeys>>(2, &self.ShardValidatorsPubKeys, os)?;
        if self.Epoch != 0 {
            os.write_uint32(3, self.Epoch)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidatorsPubKeys {
        ValidatorsPubKeys::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ShardID",
                |m: &ValidatorsPubKeys| { &m.ShardID },
                |m: &mut ValidatorsPubKeys| { &mut m.ShardID },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<PubKeys>>(
                "ShardValidatorsPubKeys",
                |m: &ValidatorsPubKeys| { &m.ShardValidatorsPubKeys },
                |m: &mut ValidatorsPubKeys| { &mut m.ShardValidatorsPubKeys },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "Epoch",
                |m: &ValidatorsPubKeys| { &m.Epoch },
                |m: &mut ValidatorsPubKeys| { &mut m.Epoch },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValidatorsPubKeys>(
                "ValidatorsPubKeys",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValidatorsPubKeys {
        static instance: ::protobuf::rt::LazyV2<ValidatorsPubKeys> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValidatorsPubKeys::new)
    }
}

impl ::protobuf::Clear for ValidatorsPubKeys {
    fn clear(&mut self) {
        self.ShardID = 0;
        self.ShardValidatorsPubKeys.clear();
        self.Epoch = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidatorsPubKeys {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidatorsPubKeys {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Accounts {
    // message fields
    pub ShardID: u32,
    pub BlockTimestamp: u64,
    pub AlteredAccounts: ::std::collections::HashMap<::std::string::String, super::alteredAccount::AlteredAccount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Accounts {
    fn default() -> &'a Accounts {
        <Accounts as ::protobuf::Message>::default_instance()
    }
}

impl Accounts {
    pub fn new() -> Accounts {
        ::std::default::Default::default()
    }

    // uint32 ShardID = 1;


    pub fn get_ShardID(&self) -> u32 {
        self.ShardID
    }
    pub fn clear_ShardID(&mut self) {
        self.ShardID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ShardID(&mut self, v: u32) {
        self.ShardID = v;
    }

    // uint64 BlockTimestamp = 2;


    pub fn get_BlockTimestamp(&self) -> u64 {
        self.BlockTimestamp
    }
    pub fn clear_BlockTimestamp(&mut self) {
        self.BlockTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_BlockTimestamp(&mut self, v: u64) {
        self.BlockTimestamp = v;
    }

    // repeated .proto.Accounts.AlteredAccountsEntry AlteredAccounts = 3;


    pub fn get_AlteredAccounts(&self) -> &::std::collections::HashMap<::std::string::String, super::alteredAccount::AlteredAccount> {
        &self.AlteredAccounts
    }
    pub fn clear_AlteredAccounts(&mut self) {
        self.AlteredAccounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_AlteredAccounts(&mut self, v: ::std::collections::HashMap<::std::string::String, super::alteredAccount::AlteredAccount>) {
        self.AlteredAccounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AlteredAccounts(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::alteredAccount::AlteredAccount> {
        &mut self.AlteredAccounts
    }

    // Take field
    pub fn take_AlteredAccounts(&mut self) -> ::std::collections::HashMap<::std::string::String, super::alteredAccount::AlteredAccount> {
        ::std::mem::replace(&mut self.AlteredAccounts, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Accounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ShardID = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.BlockTimestamp = tmp;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::alteredAccount::AlteredAccount>>(wire_type, is, &mut self.AlteredAccounts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ShardID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ShardID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.BlockTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.BlockTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::alteredAccount::AlteredAccount>>(3, &self.AlteredAccounts);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ShardID != 0 {
            os.write_uint32(1, self.ShardID)?;
        }
        if self.BlockTimestamp != 0 {
            os.write_uint64(2, self.BlockTimestamp)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::alteredAccount::AlteredAccount>>(3, &self.AlteredAccounts, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Accounts {
        Accounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ShardID",
                |m: &Accounts| { &m.ShardID },
                |m: &mut Accounts| { &mut m.ShardID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "BlockTimestamp",
                |m: &Accounts| { &m.BlockTimestamp },
                |m: &mut Accounts| { &mut m.BlockTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::alteredAccount::AlteredAccount>>(
                "AlteredAccounts",
                |m: &Accounts| { &m.AlteredAccounts },
                |m: &mut Accounts| { &mut m.AlteredAccounts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Accounts>(
                "Accounts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Accounts {
        static instance: ::protobuf::rt::LazyV2<Accounts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Accounts::new)
    }
}

impl ::protobuf::Clear for Accounts {
    fn clear(&mut self) {
        self.ShardID = 0;
        self.BlockTimestamp = 0;
        self.AlteredAccounts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Accounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Accounts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinalizedBlock {
    // message fields
    pub ShardID: u32,
    pub HeaderHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinalizedBlock {
    fn default() -> &'a FinalizedBlock {
        <FinalizedBlock as ::protobuf::Message>::default_instance()
    }
}

impl FinalizedBlock {
    pub fn new() -> FinalizedBlock {
        ::std::default::Default::default()
    }

    // uint32 ShardID = 1;


    pub fn get_ShardID(&self) -> u32 {
        self.ShardID
    }
    pub fn clear_ShardID(&mut self) {
        self.ShardID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ShardID(&mut self, v: u32) {
        self.ShardID = v;
    }

    // bytes HeaderHash = 2;


    pub fn get_HeaderHash(&self) -> &[u8] {
        &self.HeaderHash
    }
    pub fn clear_HeaderHash(&mut self) {
        self.HeaderHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_HeaderHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.HeaderHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_HeaderHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.HeaderHash
    }

    // Take field
    pub fn take_HeaderHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.HeaderHash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FinalizedBlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ShardID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.HeaderHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ShardID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ShardID, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.HeaderHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.HeaderHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ShardID != 0 {
            os.write_uint32(1, self.ShardID)?;
        }
        if !self.HeaderHash.is_empty() {
            os.write_bytes(2, &self.HeaderHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinalizedBlock {
        FinalizedBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ShardID",
                |m: &FinalizedBlock| { &m.ShardID },
                |m: &mut FinalizedBlock| { &mut m.ShardID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "HeaderHash",
                |m: &FinalizedBlock| { &m.HeaderHash },
                |m: &mut FinalizedBlock| { &mut m.HeaderHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FinalizedBlock>(
                "FinalizedBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FinalizedBlock {
        static instance: ::protobuf::rt::LazyV2<FinalizedBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FinalizedBlock::new)
    }
}

impl ::protobuf::Clear for FinalizedBlock {
    fn clear(&mut self) {
        self.ShardID = 0;
        self.HeaderHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizedBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizedBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Shard {
    // message fields
    pub ShardID: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Shard {
    fn default() -> &'a Shard {
        <Shard as ::protobuf::Message>::default_instance()
    }
}

impl Shard {
    pub fn new() -> Shard {
        ::std::default::Default::default()
    }

    // uint32 ShardID = 1;


    pub fn get_ShardID(&self) -> u32 {
        self.ShardID
    }
    pub fn clear_ShardID(&mut self) {
        self.ShardID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ShardID(&mut self, v: u32) {
        self.ShardID = v;
    }
}

impl ::protobuf::Message for Shard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ShardID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ShardID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ShardID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ShardID != 0 {
            os.write_uint32(1, self.ShardID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Shard {
        Shard::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ShardID",
                |m: &Shard| { &m.ShardID },
                |m: &mut Shard| { &mut m.ShardID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Shard>(
                "Shard",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Shard {
        static instance: ::protobuf::rt::LazyV2<Shard> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Shard::new)
    }
}

impl ::protobuf::Clear for Shard {
    fn clear(&mut self) {
        self.ShardID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Shard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Shard {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \nFgithub.com/multiversx/mx-chain-core-go/data/outport/outportBlock.prot\
    o\x12\x05proto\x1a-github.com/gogo/protobuf/gogoproto/gogo.proto\x1a=git\
    hub.com/multiversx/mx-chain-core-go/data/block/block.proto\x1aAgithub.co\
    m/multiversx/mx-chain-core-go/data/transaction/log.proto\x1aIgithub.com/\
    multiversx/mx-chain-core-go/data/transaction/transaction.proto\x1aYgithu\
    b.com/multiversx/mx-chain-core-go/data/smartContractResult/smartContract\
    Result.proto\x1aAgithub.com/multiversx/mx-chain-core-go/data/receipt/rec\
    eipt.proto\x1aCgithub.com/multiversx/mx-chain-core-go/data/rewardTx/rewa\
    rdTx.proto\x1aOgithub.com/multiversx/mx-chain-core-go/data/alteredAccoun\
    t/alteredAccount.proto\"\xbb\x07\n\x0cOutportBlock\x12/\n\x07ShardID\x18\
    \x01\x20\x01(\rR\x07ShardIDB\x15\xea\xde\x1f\x11shardID,omitempty\x12G\n\
    \tBlockData\x18\x02\x20\x01(\x0b2\x10.proto.BlockDataR\tBlockDataB\x17\
    \xea\xde\x1f\x13blockData,omitempty\x12_\n\x0fTransactionPool\x18\x03\
    \x20\x01(\x0b2\x16.proto.TransactionPoolR\x0fTransactionPoolB\x1d\xea\
    \xde\x1f\x19transactionPool,omitempty\x12s\n\x14HeaderGasConsumption\x18\
    \x04\x20\x01(\x0b2\x1b.proto.HeaderGasConsumptionR\x14HeaderGasConsumpti\
    onB\"\xea\xde\x1f\x1eheaderGasConsumption,omitempty\x12q\n\x0fAlteredAcc\
    ounts\x18\x05\x20\x03(\x0b2(.proto.OutportBlock.AlteredAccountsEntryR\
    \x0fAlteredAccountsB\x1d\xea\xde\x1f\x19alteredAccounts,omitempty\x12\\\
    \n\x16NotarizedHeadersHashes\x18\x06\x20\x03(\tR\x16NotarizedHeadersHash\
    esB$\xea\xde\x1f\x20notarizedHeadersHashes,omitempty\x12:\n\x0eNumberOfS\
    hards\x18\x07\x20\x01(\rR\x0eNumberOfShardsB\x12\xea\xde\x1f\x0enumberOf\
    Shards\x12D\n\x0eSignersIndexes\x18\x08\x20\x03(\x04R\x0eSignersIndexesB\
    \x1c\xea\xde\x1f\x18signersIndexes,omitempty\x12R\n\x16HighestFinalBlock\
    Nonce\x18\t\x20\x01(\x04R\x16HighestFinalBlockNonceB\x1a\xea\xde\x1f\x16\
    highestFinalBlockNonce\x12Y\n\x15HighestFinalBlockHash\x18\n\x20\x01(\
    \x0cR\x15HighestFinalBlockHashB#\xea\xde\x1f\x1fhighestFinalBlockHash,om\
    itempty\x1aY\n\x14AlteredAccountsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12+\n\x05value\x18\x02\x20\x01(\x0b2\x15.proto.AlteredAccoun\
    tR\x05value:\x028\x01\"\x8c\x03\n\tBlockData\x12/\n\x07ShardID\x18\x01\
    \x20\x01(\rR\x07ShardIDB\x15\xea\xde\x1f\x11shardID,omitempty\x12;\n\x0b\
    HeaderBytes\x18\x02\x20\x01(\x0cR\x0bHeaderBytesB\x19\xea\xde\x1f\x15hea\
    derBytes,omitempty\x128\n\nHeaderType\x18\x03\x20\x01(\tR\nHeaderTypeB\
    \x18\xea\xde\x1f\x14headerType,omitempty\x128\n\nHeaderHash\x18\x04\x20\
    \x01(\x0cR\nHeaderHashB\x18\xea\xde\x1f\x14headerHash,omitempty\x123\n\
    \x04Body\x18\x05\x20\x01(\x0b2\x0b.proto.BodyR\x04BodyB\x12\xea\xde\x1f\
    \x0ebody,omitempty\x12h\n\x14IntraShardMiniBlocks\x18\x06\x20\x03(\x0b2\
    \x10.proto.MiniBlockR\x14IntraShardMiniBlocksB\"\xea\xde\x1f\x1eintraSha\
    rdMiniBlocks,omitempty\"\x87\n\n\x0fTransactionPool\x12h\n\x0cTransactio\
    ns\x18\x01\x20\x03(\x0b2(.proto.TransactionPool.TransactionsEntryR\x0cTr\
    ansactionsB\x1a\xea\xde\x1f\x16transactions,omitempty\x12\x88\x01\n\x14S\
    martContractResults\x18\x02\x20\x03(\x0b20.proto.TransactionPool.SmartCo\
    ntractResultsEntryR\x14SmartContractResultsB\"\xea\xde\x1f\x1esmartContr\
    actResults,omitempty\x12T\n\x07Rewards\x18\x03\x20\x03(\x0b2#.proto.Tran\
    sactionPool.RewardsEntryR\x07RewardsB\x15\xea\xde\x1f\x11rewards,omitemp\
    ty\x12X\n\x08Receipts\x18\x04\x20\x03(\x0b2$.proto.TransactionPool.Recei\
    ptsEntryR\x08ReceiptsB\x16\xea\xde\x1f\x12receipts,omitempty\x12`\n\nInv\
    alidTxs\x18\x05\x20\x03(\x0b2&.proto.TransactionPool.InvalidTxsEntryR\nI\
    nvalidTxsB\x18\xea\xde\x1f\x14invalidTxs,omitempty\x126\n\x04Logs\x18\
    \x06\x20\x03(\x0b2\x0e.proto.LogDataR\x04LogsB\x12\xea\xde\x1f\x0elogs,o\
    mitempty\x12\x86\x01\n$ScheduledExecutedSCRSHashesPrevBlock\x18\x07\x20\
    \x03(\tR$ScheduledExecutedSCRSHashesPrevBlockB2\xea\xde\x1f.scheduledExe\
    cutedSCRSHashesPrevBlock,omitempty\x12\x98\x01\n*ScheduledExecutedInvali\
    dTxsHashesPrevBlock\x18\x08\x20\x03(\tR*ScheduledExecutedInvalidTxsHashe\
    sPrevBlockB8\xea\xde\x1f4scheduledExecutedInvalidTxsHashesPrevBlock,omit\
    empty\x1aN\n\x11TransactionsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12#\n\x05value\x18\x02\x20\x01(\x0b2\r.proto.TxInfoR\x05value:\
    \x028\x01\x1aW\n\x19SmartContractResultsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12$\n\x05value\x18\x02\x20\x01(\x0b2\x0e.proto.SCRI\
    nfoR\x05value:\x028\x01\x1aM\n\x0cRewardsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12'\n\x05value\x18\x02\x20\x01(\x0b2\x11.proto.Rewa\
    rdInfoR\x05value:\x028\x01\x1aK\n\rReceiptsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12$\n\x05value\x18\x02\x20\x01(\x0b2\x0e.proto.\
    ReceiptR\x05value:\x028\x01\x1aL\n\x0fInvalidTxsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12#\n\x05value\x18\x02\x20\x01(\x0b2\r.prot\
    o.TxInfoR\x05value:\x028\x01\"\xae\x02\n\x07FeeInfo\x12%\n\x07GasUsed\
    \x18\x01\x20\x01(\x04R\x07GasUsedB\x0b\xea\xde\x1f\x07gasUsed\x12l\n\x03\
    Fee\x18\x02\x20\x01(\x0cR\x03FeeBZ\xaa\xdf\x1fEmath/big.Int;github.com/m\
    ultiversx/mx-chain-core-go/data.BigIntCaster\xea\xde\x1f\rfee,omitempty\
    \x12\x8d\x01\n\x0eInitialPaidFee\x18\x03\x20\x01(\x0cR\x0eInitialPaidFee\
    Be\xaa\xdf\x1fEmath/big.Int;github.com/multiversx/mx-chain-core-go/data.\
    BigIntCaster\xea\xde\x1f\x18initialPaidFee,omitempty\"\xd6\x01\n\x06TxIn\
    fo\x12O\n\x0bTransaction\x18\x01\x20\x01(\x0b2\x12.proto.TransactionR\
    \x0bTransactionB\x19\xea\xde\x1f\x15transaction,omitempty\x12?\n\x07FeeI\
    nfo\x18\x02\x20\x01(\x0b2\x0e.proto.FeeInfoR\x07FeeInfoB\x15\xea\xde\x1f\
    \x11feeInfo,omitempty\x12:\n\x0eExecutionOrder\x18\x03\x20\x01(\rR\x0eEx\
    ecutionOrderB\x12\xea\xde\x1f\x0eexecutionOrder\"\xf7\x01\n\x07SCRInfo\
    \x12o\n\x13SmartContractResult\x18\x01\x20\x01(\x0b2\x1a.proto.SmartCont\
    ractResultR\x13SmartContractResultB!\xea\xde\x1f\x1dsmartContractResult,\
    omitempty\x12?\n\x07FeeInfo\x18\x02\x20\x01(\x0b2\x0e.proto.FeeInfoR\x07\
    FeeInfoB\x15\xea\xde\x1f\x11feeInfo,omitempty\x12:\n\x0eExecutionOrder\
    \x18\x03\x20\x01(\rR\x0eExecutionOrderB\x12\xea\xde\x1f\x0eexecutionOrde\
    r\"T\n\x07LogData\x12\"\n\x06TxHash\x18\x01\x20\x01(\tR\x06TxHashB\n\xea\
    \xde\x1f\x06txHash\x12%\n\x03Log\x18\x02\x20\x01(\x0b2\n.proto.LogR\x03L\
    ogB\x07\xea\xde\x1f\x03log\"\x87\x01\n\nRewardInfo\x12=\n\x06Reward\x18\
    \x01\x20\x01(\x0b2\x0f.proto.RewardTxR\x06RewardB\x14\xea\xde\x1f\x10rew\
    ard,omitempty\x12:\n\x0eExecutionOrder\x18\x02\x20\x01(\rR\x0eExecutionO\
    rderB\x12\xea\xde\x1f\x0eexecutionOrder\"\xee\x01\n\x14HeaderGasConsumpt\
    ion\x121\n\x0bGasProvided\x18\x01\x20\x01(\x04R\x0bGasProvidedB\x0f\xea\
    \xde\x1f\x0bgasProvided\x121\n\x0bGasRefunded\x18\x02\x20\x01(\x04R\x0bG\
    asRefundedB\x0f\xea\xde\x1f\x0bgasRefunded\x124\n\x0cGasPenalized\x18\
    \x03\x20\x01(\x04R\x0cGasPenalizedB\x10\xea\xde\x1f\x0cgasPenalized\x12:\
    \n\x0eMaxGasPerBlock\x18\x04\x20\x01(\x04R\x0eMaxGasPerBlockB\x12\xea\
    \xde\x1f\x0emaxGasPerBlock\"f\n\x13ValidatorRatingInfo\x12+\n\tPublicKey\
    \x18\x01\x20\x01(\tR\tPublicKeyB\r\xea\xde\x1f\tpublicKey\x12\"\n\x06Rat\
    ing\x18\x02\x20\x01(\x02R\x06RatingB\n\xea\xde\x1f\x06rating\"\xce\x01\n\
    \x10ValidatorsRating\x12%\n\x07ShardID\x18\x01\x20\x01(\rR\x07ShardIDB\
    \x0b\xea\xde\x1f\x07shardID\x12\x1f\n\x05Epoch\x18\x02\x20\x01(\rR\x05Ep\
    ochB\t\xea\xde\x1f\x05epoch\x12r\n\x14ValidatorsRatingInfo\x18\x03\x20\
    \x03(\x0b2\x1a.proto.ValidatorRatingInfoR\x14ValidatorsRatingInfoB\"\xea\
    \xde\x1f\x1evalidatorsRatingInfo,omitempty\"\x9f\x02\n\tRoundInfo\x12\
    \x1f\n\x05Round\x18\x01\x20\x01(\x04R\x05RoundB\t\xea\xde\x1f\x05round\
    \x12:\n\x0eSignersIndexes\x18\x02\x20\x03(\x04R\x0eSignersIndexesB\x12\
    \xea\xde\x1f\x0esignersIndexes\x12@\n\x10BlockWasProposed\x18\x03\x20\
    \x01(\x08R\x10BlockWasProposedB\x14\xea\xde\x1f\x10blockWasProposed\x12%\
    \n\x07ShardId\x18\x04\x20\x01(\rR\x07ShardIdB\x0b\xea\xde\x1f\x07shardId\
    \x12\x1f\n\x05Epoch\x18\x05\x20\x01(\rR\x05EpochB\t\xea\xde\x1f\x05epoch\
    \x12+\n\tTimestamp\x18\x06\x20\x01(\x04R\tTimestampB\r\xea\xde\x1f\ttime\
    stamp\"\x7f\n\nRoundsInfo\x12%\n\x07ShardID\x18\x01\x20\x01(\rR\x07Shard\
    IDB\x0b\xea\xde\x1f\x07shardID\x12J\n\nRoundsInfo\x18\x02\x20\x03(\x0b2\
    \x10.proto.RoundInfoR\nRoundsInfoB\x18\xea\xde\x1f\x14roundsInfo,omitemp\
    ty\"1\n\x07PubKeys\x12&\n\x04Keys\x18\x01\x20\x03(\x0cR\x04KeysB\x12\xea\
    \xde\x1f\x0ekeys,omitempty\"\xc6\x02\n\x11ValidatorsPubKeys\x12%\n\x07Sh\
    ardID\x18\x01\x20\x01(\rR\x07ShardIDB\x0b\xea\xde\x1f\x07shardID\x12\x8d\
    \x01\n\x16ShardValidatorsPubKeys\x18\x02\x20\x03(\x0b24.proto.Validators\
    PubKeys.ShardValidatorsPubKeysEntryR\x16ShardValidatorsPubKeysB\x1f\xea\
    \xde\x1f\x1bvalidatorsPubKeys,omitempty\x12\x1f\n\x05Epoch\x18\x03\x20\
    \x01(\rR\x05EpochB\t\xea\xde\x1f\x05epoch\x1aY\n\x1bShardValidatorsPubKe\
    ysEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03key\x12$\n\x05value\x18\
    \x02\x20\x01(\x0b2\x0e.proto.PubKeysR\x05value:\x028\x01\"\xb7\x02\n\x08\
    Accounts\x12%\n\x07ShardID\x18\x01\x20\x01(\rR\x07ShardIDB\x0b\xea\xde\
    \x1f\x07shardID\x12:\n\x0eBlockTimestamp\x18\x02\x20\x01(\x04R\x0eBlockT\
    imestampB\x12\xea\xde\x1f\x0eblockTimestamp\x12m\n\x0fAlteredAccounts\
    \x18\x03\x20\x03(\x0b2$.proto.Accounts.AlteredAccountsEntryR\x0fAlteredA\
    ccountsB\x1d\xea\xde\x1f\x19alteredAccounts,omitempty\x1aY\n\x14AlteredA\
    ccountsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12+\n\x05value\
    \x18\x02\x20\x01(\x0b2\x15.proto.AlteredAccountR\x05value:\x028\x01\"g\n\
    \x0eFinalizedBlock\x12%\n\x07ShardID\x18\x01\x20\x01(\rR\x07ShardIDB\x0b\
    \xea\xde\x1f\x07shardID\x12.\n\nHeaderHash\x18\x02\x20\x01(\x0cR\nHeader\
    HashB\x0e\xea\xde\x1f\nheaderHash\".\n\x05Shard\x12%\n\x07ShardID\x18\
    \x01\x20\x01(\rR\x07ShardIDB\x0b\xea\xde\x1f\x07shardIDBAZ;github.com/mu\
    ltiversx/mx-chain-core-go/data/outport;outport\xd8\xe2\x1e\x01b\x06proto\
    3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
